{"ast":null,"code":"var url = require(\"url\");\n\nvar URL = url.URL;\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar Writable = require(\"stream\").Writable;\n\nvar assert = require(\"assert\");\n\nvar debug = require(\"./debug\"); // Create handlers that pass events from native requests\n\n\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n}); // Error types with codes\n\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\");\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\"); // An HTTP(S) request that can be redirected\n\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n\n  this._sanitizeOptions(options);\n\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = []; // Attach a callback if passed\n\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  } // React to responses of native requests\n\n\n  var self = this;\n\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  }; // Perform the first request\n\n\n  this._performRequest();\n}\n\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n}; // Writes buffered data to the current native request\n\n\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  } // Validate input and shift parameters if necessary\n\n\n  if (!(typeof data === \"string\" || typeof data === \"object\" && \"length\" in data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n\n\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Only write when we don't exceed the maximum body length\n\n\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n\n    this._currentRequest.write(data, encoding, callback);\n  } // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n}; // Ends the current native request\n\n\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Write data if needed and end\n\n\n  if (!data) {\n    this._ended = this._ending = true;\n\n    this._currentRequest.end(null, null, callback);\n  } else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n}; // Sets a header value on the current native request\n\n\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n\n  this._currentRequest.setHeader(name, value);\n}; // Clears a header value on the current native request\n\n\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n\n  this._currentRequest.removeHeader(name);\n}; // Global timeout for all underlying requests\n\n\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this; // Destroys the socket on timeout\n\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  } // Sets up a timer to trigger a timeout event\n\n\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  } // Stops a timeout from triggering\n\n\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    } // Clean up all attached listeners\n\n\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  } // Attach callback if passed\n\n\n  if (callback) {\n    this.on(\"timeout\", callback);\n  } // Start the timer if or when the socket is opened\n\n\n  if (this.socket) {\n    startTimer(this.socket);\n  } else {\n    this._currentRequest.once(\"socket\", startTimer);\n  } // Clean up on events\n\n\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  return this;\n}; // Proxy all other public ClientRequest methods\n\n\n[\"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n}); // Proxy all public ClientRequest properties\n\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  } // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n\n\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n\n    delete options.host;\n  } // Complete the URL object when necessary\n\n\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n}; // Executes the next native request (initial or redirect)\n\n\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  } // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n\n\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  } // Create the native request and set up its event handlers\n\n\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  } // RFC7230§5.3.1: When making a request directly to an origin server, […]\n  // a client MUST send only the absolute path […] as the request-target.\n\n\n  this._currentUrl = /^\\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]\n  // a client MUST send the target URI in absolute-form […].\n  this._currentUrl = this._options.path; // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        } // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        } // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    })();\n  }\n}; // Processes a response from the current native request\n\n\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode\n    });\n  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  // If the response is not a redirect; return it as-is\n\n\n  var location = response.headers.location;\n\n  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response); // Clean up\n\n    this._requestBodyBuffers = [];\n    return;\n  } // The response is a redirect, so abort the current request\n\n\n  abortRequest(this._currentRequest); // Discard the remainder of the response to avoid waiting for data\n\n  response.destroy(); // RFC7231§6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n\n  if (++this._redirectCount > this._options.maxRedirects) {\n    this.emit(\"error\", new TooManyRedirectsError());\n    return;\n  } // Store the request headers if applicable\n\n\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\")\n    }, this._options.headers);\n  } // RFC7231§6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, […]\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n\n\n  var method = this._options.method;\n\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n  // the server is redirecting the user agent to a different resource […]\n  // A user agent can perform a retrieval request targeting that URI\n  // (a GET or HEAD request if using HTTP) […]\n  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\"; // Drop a possible entity and headers related to it\n\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  } // Drop the Host header, as the redirect might lead to a different host\n\n\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers); // If the redirect is relative, carry over the host of the last request\n\n  var currentUrlParts = url.parse(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n    host: currentHost\n  })); // Determine the URL of the redirection\n\n  var redirectUrl;\n\n  try {\n    redirectUrl = url.resolve(currentUrl, location);\n  } catch (cause) {\n    this.emit(\"error\", new RedirectionError(cause));\n    return;\n  } // Create the redirected request\n\n\n  debug(\"redirecting to\", redirectUrl);\n  this._isRedirect = true;\n  var redirectUrlParts = url.parse(redirectUrl);\n  Object.assign(this._options, redirectUrlParts); // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n\n  if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== \"https:\" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {\n    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n  } // Evaluate the beforeRedirect callback\n\n\n  if (typeof beforeRedirect === \"function\") {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders\n    };\n\n    try {\n      beforeRedirect(this._options, responseDetails, requestDetails);\n    } catch (err) {\n      this.emit(\"error\", err);\n      return;\n    }\n\n    this._sanitizeOptions(this._options);\n  } // Perform the redirected request\n\n\n  try {\n    this._performRequest();\n  } catch (cause) {\n    this.emit(\"error\", new RedirectionError(cause));\n  }\n}; // Wraps the key/value object of protocols with redirect functionality\n\n\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  }; // Wrap each protocol\n\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects\n\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n\n        try {\n          input = urlToOptions(new URL(urlStr));\n        } catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      } else if (URL && input instanceof URL) {\n        input = urlToOptions(input);\n      } else {\n        callback = options;\n        options = input;\n        input = {\n          protocol: protocol\n        };\n      }\n\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      } // Set defaults\n\n\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    } // Executes a GET request, following redirects\n\n\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    } // Expose the properties on the wrapped protocol\n\n\n    Object.defineProperties(wrappedProtocol, {\n      request: {\n        value: request,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      },\n      get: {\n        value: get,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }\n    });\n  });\n  return exports;\n}\n/* istanbul ignore next */\n\n\nfunction noop() {\n  /* empty */\n} // from https://github.com/nodejs/node/blob/master/lib/internal/url.js\n\n\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n    /* istanbul ignore next */\n    urlObject.hostname.slice(1, -1) : urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href\n  };\n\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n\n  return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(cause) {\n    Error.captureStackTrace(this, this.constructor);\n\n    if (!cause) {\n      this.message = defaultMessage;\n    } else {\n      this.message = defaultMessage + \": \" + cause.message;\n      this.cause = cause;\n    }\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n\n  request.on(\"error\", noop);\n  request.abort();\n}\n\nfunction isSubdomain(subdomain, domain) {\n  const dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n} // Exports\n\n\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"names":["url","require","URL","http","https","Writable","assert","debug","events","eventHandlers","Object","create","forEach","event","arg1","arg2","arg3","_redirectable","emit","RedirectionError","createErrorType","TooManyRedirectsError","MaxBodyLengthExceededError","WriteAfterEndError","RedirectableRequest","options","responseCallback","call","_sanitizeOptions","_options","_ended","_ending","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","on","self","_onNativeResponse","response","_processResponse","_performRequest","prototype","abort","abortRequest","_currentRequest","write","data","encoding","callback","TypeError","length","maxBodyLength","push","end","currentRequest","setHeader","name","value","headers","removeHeader","setTimeout","msecs","destroyOnTimeout","socket","removeListener","destroy","addListener","startTimer","_timeout","clearTimeout","clearTimer","once","method","a","b","property","defineProperty","get","host","hostname","pathname","path","searchPos","indexOf","substring","search","protocol","nativeProtocol","nativeProtocols","agents","scheme","slice","agent","request","_currentUrl","test","format","_isRedirect","i","buffers","writeNext","error","buffer","finished","statusCode","trackRedirects","location","followRedirects","responseUrl","redirects","maxRedirects","requestHeaders","beforeRedirect","assign","Host","req","getHeader","removeMatchingHeaders","currentHostHeader","currentUrlParts","parse","currentHost","currentUrl","redirectUrl","resolve","cause","redirectUrlParts","isSubdomain","responseDetails","requestDetails","err","wrap","protocols","exports","keys","wrappedProtocol","input","urlStr","urlToOptions","equal","wrappedRequest","defineProperties","configurable","enumerable","writable","noop","urlObject","startsWith","hash","href","port","Number","regex","lastValue","header","undefined","String","trim","code","defaultMessage","CustomError","Error","captureStackTrace","constructor","message","subdomain","domain","dot","endsWith","module"],"sources":["C:/Users/Admin/Documents/GitHub/Project/Book-Social-Network/frontend/node_modules/follow-redirects/index.js"],"sourcesContent":["var url = require(\"url\");\r\nvar URL = url.URL;\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Writable = require(\"stream\").Writable;\r\nvar assert = require(\"assert\");\r\nvar debug = require(\"./debug\");\r\n\r\n// Create handlers that pass events from native requests\r\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\r\nvar eventHandlers = Object.create(null);\r\nevents.forEach(function (event) {\r\n  eventHandlers[event] = function (arg1, arg2, arg3) {\r\n    this._redirectable.emit(event, arg1, arg2, arg3);\r\n  };\r\n});\r\n\r\n// Error types with codes\r\nvar RedirectionError = createErrorType(\r\n  \"ERR_FR_REDIRECTION_FAILURE\",\r\n  \"Redirected request failed\"\r\n);\r\nvar TooManyRedirectsError = createErrorType(\r\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\r\n  \"Maximum number of redirects exceeded\"\r\n);\r\nvar MaxBodyLengthExceededError = createErrorType(\r\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\r\n  \"Request body larger than maxBodyLength limit\"\r\n);\r\nvar WriteAfterEndError = createErrorType(\r\n  \"ERR_STREAM_WRITE_AFTER_END\",\r\n  \"write after end\"\r\n);\r\n\r\n// An HTTP(S) request that can be redirected\r\nfunction RedirectableRequest(options, responseCallback) {\r\n  // Initialize the request\r\n  Writable.call(this);\r\n  this._sanitizeOptions(options);\r\n  this._options = options;\r\n  this._ended = false;\r\n  this._ending = false;\r\n  this._redirectCount = 0;\r\n  this._redirects = [];\r\n  this._requestBodyLength = 0;\r\n  this._requestBodyBuffers = [];\r\n\r\n  // Attach a callback if passed\r\n  if (responseCallback) {\r\n    this.on(\"response\", responseCallback);\r\n  }\r\n\r\n  // React to responses of native requests\r\n  var self = this;\r\n  this._onNativeResponse = function (response) {\r\n    self._processResponse(response);\r\n  };\r\n\r\n  // Perform the first request\r\n  this._performRequest();\r\n}\r\nRedirectableRequest.prototype = Object.create(Writable.prototype);\r\n\r\nRedirectableRequest.prototype.abort = function () {\r\n  abortRequest(this._currentRequest);\r\n  this.emit(\"abort\");\r\n};\r\n\r\n// Writes buffered data to the current native request\r\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\r\n  // Writing is not allowed if end has been called\r\n  if (this._ending) {\r\n    throw new WriteAfterEndError();\r\n  }\r\n\r\n  // Validate input and shift parameters if necessary\r\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\r\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\r\n  }\r\n  if (typeof encoding === \"function\") {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Ignore empty buffers, since writing them doesn't invoke the callback\r\n  // https://github.com/nodejs/node/issues/22066\r\n  if (data.length === 0) {\r\n    if (callback) {\r\n      callback();\r\n    }\r\n    return;\r\n  }\r\n  // Only write when we don't exceed the maximum body length\r\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\r\n    this._requestBodyLength += data.length;\r\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\r\n    this._currentRequest.write(data, encoding, callback);\r\n  }\r\n  // Error when we exceed the maximum body length\r\n  else {\r\n    this.emit(\"error\", new MaxBodyLengthExceededError());\r\n    this.abort();\r\n  }\r\n};\r\n\r\n// Ends the current native request\r\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\r\n  // Shift parameters if necessary\r\n  if (typeof data === \"function\") {\r\n    callback = data;\r\n    data = encoding = null;\r\n  }\r\n  else if (typeof encoding === \"function\") {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Write data if needed and end\r\n  if (!data) {\r\n    this._ended = this._ending = true;\r\n    this._currentRequest.end(null, null, callback);\r\n  }\r\n  else {\r\n    var self = this;\r\n    var currentRequest = this._currentRequest;\r\n    this.write(data, encoding, function () {\r\n      self._ended = true;\r\n      currentRequest.end(null, null, callback);\r\n    });\r\n    this._ending = true;\r\n  }\r\n};\r\n\r\n// Sets a header value on the current native request\r\nRedirectableRequest.prototype.setHeader = function (name, value) {\r\n  this._options.headers[name] = value;\r\n  this._currentRequest.setHeader(name, value);\r\n};\r\n\r\n// Clears a header value on the current native request\r\nRedirectableRequest.prototype.removeHeader = function (name) {\r\n  delete this._options.headers[name];\r\n  this._currentRequest.removeHeader(name);\r\n};\r\n\r\n// Global timeout for all underlying requests\r\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\r\n  var self = this;\r\n\r\n  // Destroys the socket on timeout\r\n  function destroyOnTimeout(socket) {\r\n    socket.setTimeout(msecs);\r\n    socket.removeListener(\"timeout\", socket.destroy);\r\n    socket.addListener(\"timeout\", socket.destroy);\r\n  }\r\n\r\n  // Sets up a timer to trigger a timeout event\r\n  function startTimer(socket) {\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n    }\r\n    self._timeout = setTimeout(function () {\r\n      self.emit(\"timeout\");\r\n      clearTimer();\r\n    }, msecs);\r\n    destroyOnTimeout(socket);\r\n  }\r\n\r\n  // Stops a timeout from triggering\r\n  function clearTimer() {\r\n    // Clear the timeout\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n      self._timeout = null;\r\n    }\r\n\r\n    // Clean up all attached listeners\r\n    self.removeListener(\"abort\", clearTimer);\r\n    self.removeListener(\"error\", clearTimer);\r\n    self.removeListener(\"response\", clearTimer);\r\n    if (callback) {\r\n      self.removeListener(\"timeout\", callback);\r\n    }\r\n    if (!self.socket) {\r\n      self._currentRequest.removeListener(\"socket\", startTimer);\r\n    }\r\n  }\r\n\r\n  // Attach callback if passed\r\n  if (callback) {\r\n    this.on(\"timeout\", callback);\r\n  }\r\n\r\n  // Start the timer if or when the socket is opened\r\n  if (this.socket) {\r\n    startTimer(this.socket);\r\n  }\r\n  else {\r\n    this._currentRequest.once(\"socket\", startTimer);\r\n  }\r\n\r\n  // Clean up on events\r\n  this.on(\"socket\", destroyOnTimeout);\r\n  this.on(\"abort\", clearTimer);\r\n  this.on(\"error\", clearTimer);\r\n  this.on(\"response\", clearTimer);\r\n\r\n  return this;\r\n};\r\n\r\n// Proxy all other public ClientRequest methods\r\n[\r\n  \"flushHeaders\", \"getHeader\",\r\n  \"setNoDelay\", \"setSocketKeepAlive\",\r\n].forEach(function (method) {\r\n  RedirectableRequest.prototype[method] = function (a, b) {\r\n    return this._currentRequest[method](a, b);\r\n  };\r\n});\r\n\r\n// Proxy all public ClientRequest properties\r\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\r\n  Object.defineProperty(RedirectableRequest.prototype, property, {\r\n    get: function () { return this._currentRequest[property]; },\r\n  });\r\n});\r\n\r\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\r\n  // Ensure headers are always present\r\n  if (!options.headers) {\r\n    options.headers = {};\r\n  }\r\n\r\n  // Since http.request treats host as an alias of hostname,\r\n  // but the url module interprets host as hostname plus port,\r\n  // eliminate the host property to avoid confusion.\r\n  if (options.host) {\r\n    // Use hostname if set, because it has precedence\r\n    if (!options.hostname) {\r\n      options.hostname = options.host;\r\n    }\r\n    delete options.host;\r\n  }\r\n\r\n  // Complete the URL object when necessary\r\n  if (!options.pathname && options.path) {\r\n    var searchPos = options.path.indexOf(\"?\");\r\n    if (searchPos < 0) {\r\n      options.pathname = options.path;\r\n    }\r\n    else {\r\n      options.pathname = options.path.substring(0, searchPos);\r\n      options.search = options.path.substring(searchPos);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Executes the next native request (initial or redirect)\r\nRedirectableRequest.prototype._performRequest = function () {\r\n  // Load the native protocol\r\n  var protocol = this._options.protocol;\r\n  var nativeProtocol = this._options.nativeProtocols[protocol];\r\n  if (!nativeProtocol) {\r\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\r\n    return;\r\n  }\r\n\r\n  // If specified, use the agent corresponding to the protocol\r\n  // (HTTP and HTTPS use different types of agents)\r\n  if (this._options.agents) {\r\n    var scheme = protocol.slice(0, -1);\r\n    this._options.agent = this._options.agents[scheme];\r\n  }\r\n\r\n  // Create the native request and set up its event handlers\r\n  var request = this._currentRequest =\r\n        nativeProtocol.request(this._options, this._onNativeResponse);\r\n  request._redirectable = this;\r\n  for (var event of events) {\r\n    request.on(event, eventHandlers[event]);\r\n  }\r\n\r\n  // RFC7230§5.3.1: When making a request directly to an origin server, […]\r\n  // a client MUST send only the absolute path […] as the request-target.\r\n  this._currentUrl = /^\\//.test(this._options.path) ?\r\n    url.format(this._options) :\r\n    // When making a request to a proxy, […]\r\n    // a client MUST send the target URI in absolute-form […].\r\n    this._currentUrl = this._options.path;\r\n\r\n  // End a redirected request\r\n  // (The first request must be ended explicitly with RedirectableRequest#end)\r\n  if (this._isRedirect) {\r\n    // Write the request entity and end\r\n    var i = 0;\r\n    var self = this;\r\n    var buffers = this._requestBodyBuffers;\r\n    (function writeNext(error) {\r\n      // Only write if this request has not been redirected yet\r\n      /* istanbul ignore else */\r\n      if (request === self._currentRequest) {\r\n        // Report any write errors\r\n        /* istanbul ignore if */\r\n        if (error) {\r\n          self.emit(\"error\", error);\r\n        }\r\n        // Write the next buffer if there are still left\r\n        else if (i < buffers.length) {\r\n          var buffer = buffers[i++];\r\n          /* istanbul ignore else */\r\n          if (!request.finished) {\r\n            request.write(buffer.data, buffer.encoding, writeNext);\r\n          }\r\n        }\r\n        // End the request if `end` has been called on us\r\n        else if (self._ended) {\r\n          request.end();\r\n        }\r\n      }\r\n    }());\r\n  }\r\n};\r\n\r\n// Processes a response from the current native request\r\nRedirectableRequest.prototype._processResponse = function (response) {\r\n  // Store the redirected response\r\n  var statusCode = response.statusCode;\r\n  if (this._options.trackRedirects) {\r\n    this._redirects.push({\r\n      url: this._currentUrl,\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    });\r\n  }\r\n\r\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\r\n  // that further action needs to be taken by the user agent in order to\r\n  // fulfill the request. If a Location header field is provided,\r\n  // the user agent MAY automatically redirect its request to the URI\r\n  // referenced by the Location field value,\r\n  // even if the specific status code is not understood.\r\n\r\n  // If the response is not a redirect; return it as-is\r\n  var location = response.headers.location;\r\n  if (!location || this._options.followRedirects === false ||\r\n      statusCode < 300 || statusCode >= 400) {\r\n    response.responseUrl = this._currentUrl;\r\n    response.redirects = this._redirects;\r\n    this.emit(\"response\", response);\r\n\r\n    // Clean up\r\n    this._requestBodyBuffers = [];\r\n    return;\r\n  }\r\n\r\n  // The response is a redirect, so abort the current request\r\n  abortRequest(this._currentRequest);\r\n  // Discard the remainder of the response to avoid waiting for data\r\n  response.destroy();\r\n\r\n  // RFC7231§6.4: A client SHOULD detect and intervene\r\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\r\n  if (++this._redirectCount > this._options.maxRedirects) {\r\n    this.emit(\"error\", new TooManyRedirectsError());\r\n    return;\r\n  }\r\n\r\n  // Store the request headers if applicable\r\n  var requestHeaders;\r\n  var beforeRedirect = this._options.beforeRedirect;\r\n  if (beforeRedirect) {\r\n    requestHeaders = Object.assign({\r\n      // The Host header was set by nativeProtocol.request\r\n      Host: response.req.getHeader(\"host\"),\r\n    }, this._options.headers);\r\n  }\r\n\r\n  // RFC7231§6.4: Automatic redirection needs to done with\r\n  // care for methods not known to be safe, […]\r\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\r\n  // the request method from POST to GET for the subsequent request.\r\n  var method = this._options.method;\r\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\r\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\r\n      // the server is redirecting the user agent to a different resource […]\r\n      // A user agent can perform a retrieval request targeting that URI\r\n      // (a GET or HEAD request if using HTTP) […]\r\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\r\n    this._options.method = \"GET\";\r\n    // Drop a possible entity and headers related to it\r\n    this._requestBodyBuffers = [];\r\n    removeMatchingHeaders(/^content-/i, this._options.headers);\r\n  }\r\n\r\n  // Drop the Host header, as the redirect might lead to a different host\r\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\r\n\r\n  // If the redirect is relative, carry over the host of the last request\r\n  var currentUrlParts = url.parse(this._currentUrl);\r\n  var currentHost = currentHostHeader || currentUrlParts.host;\r\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\r\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\r\n\r\n  // Determine the URL of the redirection\r\n  var redirectUrl;\r\n  try {\r\n    redirectUrl = url.resolve(currentUrl, location);\r\n  }\r\n  catch (cause) {\r\n    this.emit(\"error\", new RedirectionError(cause));\r\n    return;\r\n  }\r\n\r\n  // Create the redirected request\r\n  debug(\"redirecting to\", redirectUrl);\r\n  this._isRedirect = true;\r\n  var redirectUrlParts = url.parse(redirectUrl);\r\n  Object.assign(this._options, redirectUrlParts);\r\n\r\n  // Drop confidential headers when redirecting to a less secure protocol\r\n  // or to a different domain that is not a superdomain\r\n  if (redirectUrlParts.protocol !== currentUrlParts.protocol &&\r\n     redirectUrlParts.protocol !== \"https:\" ||\r\n     redirectUrlParts.host !== currentHost &&\r\n     !isSubdomain(redirectUrlParts.host, currentHost)) {\r\n    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\r\n  }\r\n\r\n  // Evaluate the beforeRedirect callback\r\n  if (typeof beforeRedirect === \"function\") {\r\n    var responseDetails = {\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    };\r\n    var requestDetails = {\r\n      url: currentUrl,\r\n      method: method,\r\n      headers: requestHeaders,\r\n    };\r\n    try {\r\n      beforeRedirect(this._options, responseDetails, requestDetails);\r\n    }\r\n    catch (err) {\r\n      this.emit(\"error\", err);\r\n      return;\r\n    }\r\n    this._sanitizeOptions(this._options);\r\n  }\r\n\r\n  // Perform the redirected request\r\n  try {\r\n    this._performRequest();\r\n  }\r\n  catch (cause) {\r\n    this.emit(\"error\", new RedirectionError(cause));\r\n  }\r\n};\r\n\r\n// Wraps the key/value object of protocols with redirect functionality\r\nfunction wrap(protocols) {\r\n  // Default settings\r\n  var exports = {\r\n    maxRedirects: 21,\r\n    maxBodyLength: 10 * 1024 * 1024,\r\n  };\r\n\r\n  // Wrap each protocol\r\n  var nativeProtocols = {};\r\n  Object.keys(protocols).forEach(function (scheme) {\r\n    var protocol = scheme + \":\";\r\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\r\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\r\n\r\n    // Executes a request, following redirects\r\n    function request(input, options, callback) {\r\n      // Parse parameters\r\n      if (typeof input === \"string\") {\r\n        var urlStr = input;\r\n        try {\r\n          input = urlToOptions(new URL(urlStr));\r\n        }\r\n        catch (err) {\r\n          /* istanbul ignore next */\r\n          input = url.parse(urlStr);\r\n        }\r\n      }\r\n      else if (URL && (input instanceof URL)) {\r\n        input = urlToOptions(input);\r\n      }\r\n      else {\r\n        callback = options;\r\n        options = input;\r\n        input = { protocol: protocol };\r\n      }\r\n      if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = null;\r\n      }\r\n\r\n      // Set defaults\r\n      options = Object.assign({\r\n        maxRedirects: exports.maxRedirects,\r\n        maxBodyLength: exports.maxBodyLength,\r\n      }, input, options);\r\n      options.nativeProtocols = nativeProtocols;\r\n\r\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\r\n      debug(\"options\", options);\r\n      return new RedirectableRequest(options, callback);\r\n    }\r\n\r\n    // Executes a GET request, following redirects\r\n    function get(input, options, callback) {\r\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\r\n      wrappedRequest.end();\r\n      return wrappedRequest;\r\n    }\r\n\r\n    // Expose the properties on the wrapped protocol\r\n    Object.defineProperties(wrappedProtocol, {\r\n      request: { value: request, configurable: true, enumerable: true, writable: true },\r\n      get: { value: get, configurable: true, enumerable: true, writable: true },\r\n    });\r\n  });\r\n  return exports;\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() { /* empty */ }\r\n\r\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\r\nfunction urlToOptions(urlObject) {\r\n  var options = {\r\n    protocol: urlObject.protocol,\r\n    hostname: urlObject.hostname.startsWith(\"[\") ?\r\n      /* istanbul ignore next */\r\n      urlObject.hostname.slice(1, -1) :\r\n      urlObject.hostname,\r\n    hash: urlObject.hash,\r\n    search: urlObject.search,\r\n    pathname: urlObject.pathname,\r\n    path: urlObject.pathname + urlObject.search,\r\n    href: urlObject.href,\r\n  };\r\n  if (urlObject.port !== \"\") {\r\n    options.port = Number(urlObject.port);\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction removeMatchingHeaders(regex, headers) {\r\n  var lastValue;\r\n  for (var header in headers) {\r\n    if (regex.test(header)) {\r\n      lastValue = headers[header];\r\n      delete headers[header];\r\n    }\r\n  }\r\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\r\n    undefined : String(lastValue).trim();\r\n}\r\n\r\nfunction createErrorType(code, defaultMessage) {\r\n  function CustomError(cause) {\r\n    Error.captureStackTrace(this, this.constructor);\r\n    if (!cause) {\r\n      this.message = defaultMessage;\r\n    }\r\n    else {\r\n      this.message = defaultMessage + \": \" + cause.message;\r\n      this.cause = cause;\r\n    }\r\n  }\r\n  CustomError.prototype = new Error();\r\n  CustomError.prototype.constructor = CustomError;\r\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\r\n  CustomError.prototype.code = code;\r\n  return CustomError;\r\n}\r\n\r\nfunction abortRequest(request) {\r\n  for (var event of events) {\r\n    request.removeListener(event, eventHandlers[event]);\r\n  }\r\n  request.on(\"error\", noop);\r\n  request.abort();\r\n}\r\n\r\nfunction isSubdomain(subdomain, domain) {\r\n  const dot = subdomain.length - domain.length - 1;\r\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\r\n}\r\n\r\n// Exports\r\nmodule.exports = wrap({ http: http, https: https });\r\nmodule.exports.wrap = wrap;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}